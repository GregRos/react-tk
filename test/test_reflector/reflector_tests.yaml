test framework: pytest
folders:
  test_reflector:
    file KeyAccessor:
      setup:
        dummy_exists: has attribute = 123
        doesnt_exist: no attribute
      get():
        when attr exists: 123
        when attr doesnt: raises KeyError
        pass default: 456
      set:
        overwrites existing: 789
        creates new: 101112
      has_key:
        when attr exists: True
        when attr doesnt: False
      __bool__:
        when attr exists: True
        when attr doesnt: False
    file Reader_Annotation:
      test target: # target is preserved

      test name:
        - int # int
        - list[int] # list
        - dict[str, int] # dict
        - Annotated[int, "meta"] # Annotated
        - Unpack[SomeTypedDict] # Unpack
        - NotRequired[int] # NotRequired
        - Optional[int] # Optional
        - Union[int, str] # Union
      test inner_type: # extracts inner type
        - plain type: int #-> int
        - generic type: list[int] #-> list[int]
        - generic2 type: dict[str, int] #-> dict[str, int]
        - annotated 1: Annotated[int, "meta"] #-> int
        - unpack: Unpack[SomeTypedDict] #-> SomeTypedDict
        - not required: NotRequired[int] #-> int
        - annotated[not required]: Annotated[Unpack[SomeTypedDict], "meta"] #-> SomeTypedDict
        - optional: Optional[int] #-> int
        - required: Required[int] #-> int
        - annotated->optional: Annotated[Optional[int], "meta"] #-> int
        - annotated->not required: Annotated[NotRequired[int], "meta"] #-> int
      test inner_type_reader: # extracts inner type reader, test with equality
        - plain type: Reader_Annotation(int) # itself
        - generic type: Reader_Annotation(list[int]) # itself
        - generic2 type: Reader_Annotation(dict[str, int]) # itself
        - union type: # throws ValueError
      test metadata: # extracts metadata from Annotated
        - plain type: int # ()
        - generic type: list[int] # ()
        - annotated 1: Annotated[int, "meta"] # ("meta",)
        - annotated 2: Annotated[list[int], "meta1", "meta2"] # ("meta1", "meta2")
        - not_required: Annotated[NotRequired[int], "meta1"] # ("meta1",)
      test metadata_of_type: # extracts only metadata of a specific type
        - str: Annotated[int, "meta", 123] # ("meta",)
        - str, int: Annotated[int, "meta", 123, ()] # ("meta", 123, "more")
    file reader_Method:
      test target: # target oreserved
      test name: gets name of target
      test _debug_signature: # should print target signature
      test arg:
        index in range: gets annotation of argument
        index out of range: raises IndexError
      test returns:
        return annotation: gets return annotation
        no return annotation: raises ValueError
    file Reader_Class:
      setup:
        - define class Dummy...
        - define class Inherited(Dummy)...
      case Dummy:
        test target: # target is preserved
        test generic target:
          - list[int] read as list
          - dict[str, int] read as dict
          - Annotated[int, ""] raises ValueError
          - Unpack[SomeTypedDict] raises ValueError
          - NotRequired[int] raises ValueError
        test name: gets name of class
        test _debug_signature: # should print target signature
        test annotations:
          all: gets all annotations as mapping
        test methods:
          all: gets all methods as mapping
        test annotation:
          exists: gets specific annotation by name
          doesnt exist: raises KeyError
        test method:
          exists: gets specific method by name
          doesnt exist: raises KeyError
      case Inherited:
        test methods:
          - includes all methods
        test annotations:
          - includes all annotations
        test annotation: = inherited annotation
          - own annotation
        test method: = inherited method
          - own method
    file Reader_TypeVar:
      setup:
        # wrap these using r.type_var(...)
        Simple: TypeVar("A")
        Extra: TypeVar("Extra")
        Bounded: TypeVar("B", bound=int)
        Defaulted: TypeVar("C", default=str)
      # run for each TypeVar using parametrized tests
      # EACH ENTRY HERE IS A SEPARATE TEST
      test name: gets name of TypeVar
      test bound:
        - Simple: None
        - Bounded: int
        - Defaulted: None
      test default:
        - Simple: None
        - Bounded: None
        - Defaulted: str
      test __str__:
        Simple: "A"
        Bounded: "B: int"
        Defaulted: "C = str"
      test is_similar:
        Simple:
          construct with same structure: true
          Extra: false
        Bounded:
          construct with same structure: true
          Extra: false
        Defaulted:
          construct with same structure: true
          Extra: false
      test Reader_TypeVarBound:
        setup:
          Simple_: Reader_TypeVarBound(Simple, int)
          Bounded_: Reader_TypeVarBound(Bounded, int)
          Defaulted_: Reader_TypeVarBound(Defaulted, str)
        
    file Reader_Generic:
      setup:
        - create Generic1[A]
        - create Generic2[A, B]
      test target: # target is preserved
       # use parameterized tests
      test origin:
        - list[int] # -> list
        - dict[str, int] # -> dict
        - dist # -> dist
        - Annotated[int, ""] # Annotated
        - Unpack[SomeTypedDict] # Unpack
        - NotRequired[int] # NotRequired
        - Generic1[int] # Generic1
        - Generic2[int, str] # Generic2
      test args and arg(n):
        special: # compare with is_similar
          Generic1[int]: Simple.with_value(int)
          Generic2[int, str]: Bounded.with_value(str), Defaulted.with_value(int)

          list[int]: TypeVar("_1", int)
        - list[int] read as TypeVar
        - dict[str, int] read as (str, int)
        - dict[str, list[int]] read as (str, list[int])
        - dict[str, dict[int, str]] read as (str, dict[int, str])
