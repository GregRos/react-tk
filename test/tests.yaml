test framework: pytest
tests:
  module KeyAccessor:
    setup:
      dummy_exists: has attribute = 123
      doesnt_exist: no attribute
    get():
      when attr exists: 123
      when attr doesnt: raises KeyError
      pass default: 456
    set:
      overwrites existing: 789
      creates new: 101112
    has_key:
      when attr exists: True
      when attr doesnt: False
    __bool__:
      when attr exists: True
      when attr doesnt: False
  module Reader_Annotation:
    test target: # target is preserved

    test name:
      - int # int
      - list[int] # list
      - dict[str, int] # dict
      - Annotated[int, "meta"] # Annotated
      - Unpack[SomeTypedDict] # Unpack
      - NotRequired[int] # NotRequired
      - Optional[int] # Optional
      - Union[int, str] # Union
    test inner_type: # extracts inner type
      - plain type: int #-> int
      - generic type: list[int] #-> list[int]
      - generic2 type: dict[str, int] #-> dict[str, int]
      - annotated 1: Annotated[int, "meta"] #-> int
      - unpack: Unpack[SomeTypedDict] #-> SomeTypedDict
      - not required: NotRequired[int] #-> int
      - annotated[not required]: Annotated[Unpack[SomeTypedDict], "meta"] #-> SomeTypedDict
      - optional: Optional[int] #-> int
      - required: Required[int] #-> int
      - annotated->optional: Annotated[Optional[int], "meta"] #-> int
      - annotated->not required: Annotated[NotRequired[int], "meta"] #-> int
    test inner_type_reader: # extracts inner type reader, test with equality
      - plain type: Reader_Annotation(int) # itself
      - generic type: Reader_Annotation(list[int]) # itself
      - generic2 type: Reader_Annotation(dict[str, int]) # itself
      - union type: # throws ValueError
    test metadata: # extracts metadata from Annotated
      - plain type: int # ()
      - generic type: list[int] # ()
      - annotated 1: Annotated[int, "meta"] # ("meta",)
      - annotated 2: Annotated[list[int], "meta1", "meta2"] # ("meta1", "meta2")
      - not_required: Annotated[NotRequired[int], "meta1"] # ("meta1",)
    test metadata_of_type: # extracts only metadata of a specific type
      - str: Annotated[int, "meta", 123] # ("meta",)
      - str, int: Annotated[int, "meta", 123, ()] # ("meta", 123, "more")
  module reader_Method:
    test target: # target oreserved
    test name: gets name of target
    test _debug_signature: # should print target signature
    test arg:
      index in range: gets annotation of argument
      index out of range: raises IndexError
    test returns:
      return annotation: gets return annotation
      no return annotation: raises ValueError
  module Reader_Class:
    test target: # target is preserved
    test name: gets name of class
    test _debug_signature: # should print target signature
    test annotations:
      all: gets all annotations as mapping
    test methods:
      all: gets all methods as mapping
    test annotation:
      exists: gets specific annotation by name
      doesnt exist: raises KeyError
    test method:
      exists: gets specific method by name
      doesnt exist: raises KeyError
